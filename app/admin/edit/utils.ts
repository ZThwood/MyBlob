export const mark_content =
    '---\nhighlight: a11y-dark\n---\n\n原先中控屏的打包脚本只支持修改中控屏的版本环境，还没支持上版本号与自动打tag。\n\n居于效率的考虑这次在原先脚本的基础上扩展两个新功能：\n\n*   自定义版本号\n*   自动打tag\n\n## 打包流程\n\n执行命令\n\n`python3 android\\_build.py ${环境} ${版本名} --official`\n\n例如：\n\n`python3 android\\_build.py normal v1.9.0 --official`\n\n含义：打包uiid195现网版本1.9.0的包，并打上名为v1.9.0的git tag\n\n### 流程图\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/03f33288989947fc958e437fb2a9cd3d~tplv-k3u1fbpfcp-zoom-1.image)\n\n```mermaid\ngraph TD;\n    A[开始] --\u003e B["获取当前时间dateTime"]\n    B --\u003e C["修改应用版本号"]\n    C --\u003e N{是否执行成功}\n    N -- 是 --\u003e D["执行 Android打包脚本"]\n    N -- 否 --\u003e J["抛出异常"]\n    D --\u003e E{"是否使用--official参数"}\n    E -- 是 --\u003e F["获取 Git 标签信息"]\n    F --\u003e M{是否执行成功}\n    M -- 是 --\u003e G["创建或更新 Git 标签"]\n    M -- 否 --\u003e J\n    H --\u003e I[结束]\n    E -- 否 --\u003e H["上传 APK 到 fir.im \n    fir_upload(dateTime)"]\n    G--\u003e Z{是否执行成功}\n    Z -- 是 --\u003e H\n    Z -- 否 --\u003e J\n    J --\u003e K[结束]\n```\n\n## 功能一：自定义版本号\n\n#### 背景：\n\n每次需要修改中控屏版本号时就必须手动修改对应版本号，再提交到仓库，不胜其烦。\n\n假如要打10个不同版本的包，就需要经历10次改代码、提代码、等待打包完毕这样的步骤，效率是非常低。于是我们考虑利用原先的打包脚本，扩展一个可以让用户可以自己打指定版本包的脚本。\n\n#### 原理：\n\n首先先使用插件[react-native-config](https://github.com/luggit/react-native-config)来管理环境变量\n\nReact Native Config是一个用于管理环境变量的库，可以在React Native项目中使用。\n\n安装和配置完成后，可以在代码中使用类似于process.env的方式来获取环境变量的值\n\n1.  创建一个.env文件\n\n```env\nTEST_ENVIRONMENT="false"  // 控制是否为测试环境\nVERSION_ENVIRONMENT="normal" // 版本控制\nAPP_VERSION="1.6.0" // 版本号\n```\n\n2.  在app中配置好env文件的变量获取\n\n```build.gradle\n\n    apply from: project(\':react-native-config\').projectDir.getPath() + "/dotenv.gradle"\n\n    ...\n    android { \n      ...\n      versionName project.env.get("APP_VERSION") // 获取版本号\n      ...\n    }\n    ...\n```\n\n这样每次app打包时会读取.env配置文件的变量，因此，只需要在每次打包前把.env文件的变量值重新覆盖即可控制当前版本环境\n\n![](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2ecbaa0e23a64920ab6e967f627bd365~tplv-k3u1fbpfcp-zoom-1.image)\n\njs代码内利用\'react-native-config\'即可访问.env配置文件对应的变量\n\n```js\n    import Config from \'react-native-config\';\n    Config.VERSION_ENVIRONMENT // normal\n```\n\n#### 脚本：\n\n##### 流程图\n\n```mermaid\ngraph TD;\n    A[开始] --\u003e B["检查命令行参数"]\n    B --\u003e C{是否满足条件}\n    C -- 是 --\u003e D["读取文件内容"]\n    D --\u003e E["定义要替换的变量名和新的值"]\n    E --\u003e F["执行替换操作"]\n    F --\u003e G["将替换后的内容写回文件中"]\n    G --\u003e H["返回修改后的版本号"]\n    H --\u003e I[结束]\n    C -- 否 --\u003e J["抛出异常"]\n    J --\u003e I\n\n    style A fill:#f9f,stroke:#333,stroke-width:2px;\n\n```\n\n##### 源码\n\n```js\n function modify_app_version() {\n    // app 版本号修改\n    if (process.argv.length \u003e= 2 \u0026\u0026 process.argv[1].startsWith(\'v\')) {\n        process.argv[1] = process.argv[1].substring(1); // 去掉字符串前面的 \'v\'\n        \n        // 读取文件内容\n        const fs = require(\'fs\');\n        let content = fs.readFileSync(envFilePath, \'utf8\');\n\n        // 定义要替换的变量名和新的值\n        const variable_name = \'APP_VERSION\';\n        const appVersion = process.argv[1];\n        console.log("========================= appVersion ========================= ", appVersion);\n\n        // 进行替换操作\n        const new_content = content.replace(variable_name, appVersion);\n\n        // 将替换后的内容写回文件中\n        fs.writeFileSync(envFilePath, new_content);\n\n        return \'v\' + appVersion;\n    } else {\n        throw new Error(\'modify_app_version 执行失败\');\n    }\n}\n```\n\n## 功能二：自动打TAG方案\n\n#### 背景：\n\n每次新版本发布都需要手动给每个版本包进行版本控制\\\n人工操作可以会出现忘记打tag的情况，会增加记忆成本\\\n而自动打tag方案可以通过命令行工具调用 Git 命令行来实现自动创建或更新 Git Tag，从而提高版本控制的效率。\n\n#### 原理：\n\n实现原理是通过命令行工具调用 Git 命令行来实现自动创建或更新 Git Tag\n\n#### 脚本：\n\n##### 流程图\n\n```mermaid\ngraph TD;\n    A[开始执行自动打tag] --\u003e B[切换到指定的git文件目录];\n    B --\u003e C[获取当前git tag列表];\n    C --\u003e D[判断是否为最新版本];\n    D -- 是 --\u003e E[抛出异常];\n    D -- 否 --\u003e F[判断标签是否已存在];\n    F -- 是 --\u003e G[抛出异常];\n    F -- 否 --\u003e H[添加新标签];\n    H --\u003e I[打上新的tag];\n    I --\u003e J[推送tag到远程仓库];\n    J --\u003e K[提交新tag];\n    K --\u003e L[结束];\n    E --\u003e L;\n    G --\u003e L;\n```\n\n##### 代码示例\n\n```js\nconst { execSync } = require(\'child_process\');\nconst path = require(\'path\');\n\n/**\n * git tag的创建与更新\n * @param tagName tag名\n * @param describe tag 描述\n * @param repoDir git所在目录\n * @param remoteName git远程名\n * @returns \n */\nfunction createOrUpdateGitTag(tagName, describe, repoDir = \'../\', remoteName = \'origin\') {\n  console.log(`开始执行自动打tag create_or_update_git_tag ${tagName} ${describe}`);\n  try {\n    // 1. 切换到指定的git文件目录\n    process.chdir(path.resolve(__dirname, repoDir));\n    console.log(`进入指定的git文件目录 ${repoDir} success`);\n\n    // 2. 获取当前git tag列表\n    let tagList = [];\n    const output = execSync(\'git tag --format=%(refname:short)\').toString().trim();\n\n    if (output) {\n      tagList = output.split(\'\\n\');\n      console.log(`获取当前git tag列表 ${tagList} success`);\n    }\n\n    // 3. 判断是否为最新版本\n    // 如果是最新版本则更新，否则不更新\n    const isLatest = isLatestVersion(tagName, tagList);\n    console.log(`是最新的tag吗？${isLatest}`);\n    if (!isLatest) {\n      return;\n    }\n\n    // 如果当前tag已经被打上tag，则不处理\n    if (tagList.includes(tagName)) {\n      console.log(`当前tag已经被打上tag ${tagName}`);\n      throw new Error(`当前tag已经被打上tag ${tagName}`);\n    } else {\n      console.log(`准备添加新tag ${tagName}`);\n    }\n\n    // 4. 打上新的tag\n    execSync(`git tag -a ${tagName} -m ${describe}`);\n\n    // 5. 推送tag到远程仓库\n    execSync(`git push ${remoteName} ${tagName}`);\n    console.log(`提交新tag ${tagName} success`);\n  } catch (error) {\n    console.log(\'create_or_update_git_tag执行错误\', error);\n  }\n}\n\n\n```\n';
